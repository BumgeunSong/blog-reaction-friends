# 오늘 프로젝트를 진행하면서 고친 문제와 마주친 문제

## 해결한 문제
1. 서브뷰의 접근제어자를 private으로 유지하면서, `addTarget()`호출하기
    - 뷰 계층화하는 과정에서 서브뷰에 필요한 색상 선택/투명도 단계 입력을 `addTarget()`으로 전달하려면, 해당 UI요소의 접근제어자를 public으로 설정해야 하는 문제가 있었다. `ViewController`에서 해당 UI에 접근하여야 했기 때문이었다.
    - `StatusSection`에서 별도로 `addTarget()`을 진행하는 함수 `setStatusTarget()`을 만들어, `ViewController`에서 호출하도록 하였다. 더이상 `ViewController`에서 접근할 이유가 없기에, 두 UI 요소를 다시 `private`으로 유지할 수 있었다.
2. 뷰 세팅을 담당하는 `setUpView()` 작성
    - 현재 코드는 `required init?(coder:)` 생성자를 호출할 때는, 원하는 초기화가 제대로 진행되지 않았다. 모든 뷰 세팅을 `override init(frame:)`안에 넣어놓았기 때문이었다.
    - `required init?(coder:)`안에도 뷰 세팅 코드를 추가하면서도 중복 코드를 없애기 위해, 앞으로 모든 뷰 세팅은 `setUpView()`를 작성하여 이 함수를 호출하기로 하였다.
3.  계산 프로퍼티의 접근제어자 문제 해결
    - `Square.alpha`의 `setter`를 계산 프로퍼티로 작성하는 과정에서 `getter`의 매개변수로 사용하는 _alpha의 접근제어자가 `public`으로 방치되어 있었고, 이후 `private`으로 수정하였다.
4. 사각형 생성 로직 수정
    - 사각형이 `DrawingSection`을 넘어가지 않도록 생성되는 방법으로, 조건에 맞는 x/y/width/height 값이 나올 때까지 while문을 사용하는 로직을 쓰고 있었다.
    - 이후, x/y 값을 기반으로 범위를 벗어나지 않는 width/height를 도출하는 로직으로 수정하였다.

## 마주친 문제
1. 입력 흐름과 출력 흐름 분리
    - Step3의 키워드는 관찰자 패턴이다. 특히, square를 추가하는 동작과 squareView를 추가하는 동작을 입력/출력 흐름으로 분리한 뒤, 관찰자 패턴을 적용하는 게 이번 단계의 핵심 목표로 보인다.
    - 직전 단계에서, **입력을 처리하는 곳은 plane 호출**하는 코드만 있고, **출력을 처리하는 곳은 plane에서 이벤트를 받아 뷰를 추가하는 코드**만 있도록 수정해보라는 리뷰를 받았다. 아마 square뷰를 추가하는 로직에서 NSNotificationCenter를 기반으로 한 옵저버 패턴을 적용해야 할 듯하다.
    - 우선은, 입력을 어떻게 분리할지부터 생각해 보아야겠다.