# unowned 와 weak 를 알아보자

보통은 클로저 내에서 자기 자신의 타입을 참조할 때 순환 참조를 피하기 위해서 `[weak self]`를 사용하는데
`unowned`도 언제 한번 들어 본 기억이 있어서 이를 이참에 정리하려 합니다.

ARC 가 RC 가 0 인 객체들은 알아서 메모리에서 해제를 시켜주는 데, 
이 때 retain cycle 을 서로 보유하고 있는 객체들은 메모리에서 해제 될 수가 없다. 

즉, 서로가 서로를 알고 있으면 강한 결합으로 묶여 있는데, weak, unowned를 사용하면 RC가 더해지거나, 빼지지 않는다.

## weak

1. 약한 참조라 해서 실제 소유권을 가지고 있지 않고, 포인터(참조)만 가지고 있는 개념이다.
2. reference count가 늘어나지 않고, release 도 발생하지 않는다. 
3. 해제시킬 수 있는 권한이 다른 클래스에 있다.
4. 메모리가 해제 될 경우 자동으로 레퍼런스를 nil로 한다.
5. weak 속성을 가지는 객체는 optional 타입이어야 한다.(nil 일 수 있다.)

## unowned

1. RC를 증가시키지 않는다. 
2. nil일 수 없다. 확실하게 생성되어 있는 객체에 대해서만 해야한다.
3. 해당 인스턴스의 소유권을 가지지 않는다.

## 둘의 차이점

- weak 는 객체를 추적하면서 nil인지 아닌지 추적하는데,  그 비용이 든다.
- unowned 개발자가 객체의 생명주기가 어떻게 되는지 인지하고 선언을 하기 때문에, 없는 값을 참조할 경우 크래시는 나지만, 항상 추적하진 않으므로 비용이 적다.
- weak 는 self?.~ 이렇게 써야하는데, unowned 는 self.~ 이렇게 쓸 수 있어 간결하다.

## 결론 

- 두 객체가 서로 참조해야하는 상황에서 weak 나 unowned 를 사용해야한다. 
- weak 는 delegate 패턴 처럼 self 선언 해주기 전까지는 값이 nil인 경우에 사용하고, 
- unowned 는 일반적인 클로저에서 self 를 사용해야 하는 경우, 자기 자신의 객체는 반드시 생성되어 있으므로 nil일 수가 없다. 
	- weak 에 비해 깔끔한 타이핑이 가능하다. 
