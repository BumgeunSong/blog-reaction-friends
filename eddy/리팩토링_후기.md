# 거대 ViewController 해체하기 - 그러나 결국 해체되는 건 나였다

## Intro

iOS 개발을 배우면서 다양한 프로젝트를 진행해봤다. 그 과정에서 느낀 점이 있다. 프로젝트를 하나 하더라도, 내가 배우고 싶은 것 도전해보고 싶은 것을 명확하게 정하는 게 정말 중요하다. 

물론 일단 당장 기능 구현하는 것도 어렵다. 적당히 돌아가게 만들고 PR를 날리는 데 집중하게 된다. 일단은 돌아가게 만들고, 일단은 이것부터 하고...

하지만 실력이 늘기 위해서는, 단순한 기능 하나라도 더 나은 방법은 없을지 고민해봐야 한다. 그렇게 한 뎁스, 두 뎁스를 내려갔을 때 얻는 게 더 많다. 무엇을 만드는지는 사실 크게 중요하지 않다. 그러기 위해선 기능 구현이 아니라 내가 연습하려고 하는 부분을 명확하게 의식적으로 설정해야 한다. 그 부분을 고립시켜서 깊이있게 해보는 게 중요하다.

이번 프로젝트에서 나의 학습 목표는 '단위 테스트와 리팩토링'이었다. 단일 책임 원칙을 잘 지키는 객체 지향 설계를 해보고 싶었다. 객체의 역할을 의미있게 나누기 위해서 이렇게도 바꿔보고, 저렇게도 바꿔보고 다양한 시도를 했다.

전체 개발 시간의 50% 이상을 리팩토링에 사용한 것 같다.


기능은 단순했다. 클릭 3번이면 끝난다. 하지만 총 3번이나 구조를 갈아엎는 대공사를 했다. 거진 2주가 걸렸다. 

삽질을 많이 했다. 결과적으로는 여태까지 만들었던 앱 중 가장 역할 분리가 잘 되고, 결합도가 낮은 구조를 만들 수 있었던 것 같다.

아마 2주 간의 여정이니 꽤 길겠지만, 압축해서 그 삽질의 과정을 기록해보려고 한다.

## 기능 소개

이번 프로젝트에 구현한 것은 에어비앤비 기능의 일부다. 위치 검색, 날짜 검색, 가격 검색을 통해서 원하는 숙박 조건을 설정하고, 그에 맞는 숙박 리스트를 받아오는 것이었다.

이 중에서도 오늘 얘기할 부분은, 위치 검색 기능이다.
흐름은 다음과 같다. 

초기 화면에서 서치 바를 탭하면 위치 검색 기능으로 진입한다. 추천 여행지가 콜렉션 뷰에 보여진다. 

이 중에서 하나를 고르게 되면 바로 Location Search가 끝나게 된다.

만약 고르지 않고 검색을 시작하면, 자동완성이 시작된다.
애플 MapKit에는 자동완성을 제공해주는 API가 있다. 이 데이터를 가져와서 콜렉션 뷰에 띄워준다.

자동완성 키워드 중 하나를 선택하면, 2가지 경우의 수가 존재한다.

해당 검색 키워드에 대한 장소 결과가 딱 하나밖에 없는 경우는 곧장 Location Search가 완료된다.

장소 결과가 여러개인 검색어, School이라든지, Coffee 같은 것들은 한번더 상세 검색 화면이 뜨게 된다. 

이제 키워드가 아닌 실제 장소가 뜬다. 이 장소를 선택하면 Location Search가 완료된다.

## 개요

간단하게 요약하면, 크게 3가지 부분으로 나눌 수 있다.

1. 거대 ViewController 역할 분리하기

2. Delegate를 DataSource와 합치기

3. 의존성을 추상 타입으로 바꾸기

물론 실제로 진행이 이렇게 논리적이고 깔끔하게 진행되진 않았다. 좌충우돌의 연속이었고, 정확히 이 순서도 아니었다. 하지만 이해를 쉽게 하기 위해서 사후적으로 다듬었으니 양해 바란다.

## 1. 거대 ViewController 역할 분리하기

이번 프로젝트는 MVC 구조로 만들었다. MVC를 선택했던 이유는, MVC를 '제대로' 했을 때 어떻게 다른지 보고 싶어서였다. 

흔히 MVC는 Massive View controller라고 불린다. 하지만 Massive View Controller가 되는 이유는, MVC의 문제라기보다는 제대로 역할 분리를 하지 않았기 때문인 경우가 많다. MVP든 MVVM이든 마찬가지로 역할 분리를 잘 하지 못하면 거대 객체는 또 등장하기 마련이다. 그래서 여기서 '제대로 했을 때' 라는 것은 단일 책임 원칙을 지키는 MVC를 만들어보자는 뜻이었다. 

먼저 위치 검색 기능을 러프하게 구현했다. 그때까지 위치 검색 기능의 구조는 아주 전형적인 거대 뷰 컨트롤러의 형태를 하고 있다. 
`LocationSearchVC`라는 하나의 객체가 다음의 역할을 모두 하고 있다.

- SearchBar, CollectionView에 대한 설정과 레이아웃 세팅
- CollectionView의 Delegate와 DataSource 역할
- MapKit과 Back-end에서 데이터 불러오기

 이제부터 이 거대 뷰 컨트롤러를 해체해보도록 하자!


1. DataSource, Delegate 분리하기

UICollectionView를 가지고 있다. DataSource 역할을 하고 있다. DataSource를 먼저 별도로 분리해주었다. NSObject의 서브클래스로 만들어준다. 

## 역할별 DataSource 분리

위에 기능설명에서 말했다시피, 위치 검색은 추천 장소를 보여주다가 검색이 시작되면 검색 키워드를 보여준다. 이 변화를 처리하기 위해 원래 코드는 조건문을 사용하고 있었다.

```swift
func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
		if searchText == "" {
		    isSearching = false
		    searchResultData.removeAll()
		    collectionView.reloadData()
		}
		else {
		    isSearching = true
		    searchCompleter.queryFragment = searchText
		}
}
```

searchBar에서 입력이 들어오면, isSeaching이 true로 바뀐다. 그러면 검색 결과 데이터를 지우고, 콜렉션의 데이터를 리로드했다. 

```swift
func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
    if isSearching{
        return searchResultData.count
    }
    return recommendationData.count
}
```

리로드를 할 때는 collectionView 데이터소스 메서드가 실행된다. 이 때 조건문으로 분기를 해서 사용하는 데이터를 바꿔주는 식이었다.

DataSource를 분리하고 난 다음에는, 메서드마다 조건문을 넣어서 분기하지 않고, 서치 이벤트가 발생되면 DataSource를 갈아끼우는 식으로 정리가 가능해졌다. 

DataSource를 하나로 분리한게 아니라 총 3개로 분리했다. 추천 데이터, 자동완성 데이터, 검색 결과 데이터. 왜냐하면 추천, 자동완성, 최종 검색 각 단계에 따라서 서로 완전히 다른 인스턴스 변수를 참조하기 때문이다.

이제 상위 ViewController는 이벤트(검색 시작, 장소 선택) 등에 따라 서로 다른 Datasource를 갈아끼워주는 역할만 하게 된다.

Delegate로 마찬가지로 분리해주었다. Delegate의 주 책임은 Cell에 대한 터치가 들어왔을 때 이벤트 처리를 하는 것이다. 깔끔했던 DataSource와 달리 Delegate까지 분리하면서는 문제가 발생했다. 여기에 대해서는 다음 챕터에 다시 설명하도록 하자.
