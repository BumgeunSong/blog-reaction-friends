## Massive View Controller를 해체해보자 - 리팩토링 후기
(하지만 결국 해체되는 건 나였다?)

iOS 개발을 배우면서 짧은 시간 내에 다양한 프로젝트를 진행해봤다. 

처음 보는 기능을 접하면, 당장 구현하기에 급급해진다. 어떻게든 돌아가게 만들고, 코드를 푸시하는데 집중한다. 일단 이것부터 하고 고치자. 이것부터 하고... 시야가 좁아진다.

하지만 그 과정을 거치면서 느꼈다. 실력이 늘기 위해서는, 더 나은 방법은 없을지 고민해야 한다. 적당히 되는 수준에서, 한 뎁스, 두 뎁스를 내려간다. 겉으로 별로 바뀌는 건 없다. 하지만 배우는 게 많다. 

뎁스를 챙기려면, 집중할 부분을 선택해야 한다. 모든 걸 다 파볼 수는 없다. 방향을 잃지 않으려면 처음부터 내가 실력을 쌓고 싶은 부분을 의식적으로 설정해야 한다. 

마치 무술가가, 똑같은 발차기를 계속 반복 연습하듯이 말이다. 


![kick](https://i.pinimg.com/originals/d5/9d/08/d59d08aaef8301e34b0b32f122c21e94.jpg)


> 당신이 요즘 연습하고 있는 발차기는 무엇인가?

이번 프로젝트에서 나의 '발차기'는 **'단위 테스트와 리팩토링'**이었다. 

객체 지향적인 코드, 역할이 잘 나눠진 코드를 만들기 위해서 코드를 여러번 뒤집었다.

기능은 단순했지만, 총 3번이나 갈아엎는 대공사를 했다. 전채 개발 시간의 50% 이상을 리팩토링에 사용한 것 같다. 그만큼 삽질도 많이 했다. 

글이 꽤 길다. 하지만 iOS 개발을 하다보면 흔히 발생하는 상황들이다. 이 글을 다 읽고나면, 여러분도 **코드 구조를 개선하는 힌트를 분명 얻을 수 있을 것**이다. 

# 기능 소개

리팩토링할 코드가 하는 일을 간단하게 이해하고 넘어가자.

에어비앤비 숙박 검색. 위치, 날짜, 가격 조건을 설정한다. 거기에 맞는 숙박 리스트를 받아온다.

이 중 오늘 얘기할 부분은 '위치 검색' 기능이다.

1. 검색 탭이 활성화되면, 사용자 현재 위치 근처의 장소들이 추천된다.
2. 검색어를 입력하면 애플 맵을 사용해 검색어 자동완성이 뜬다.
3. 검색어를 선택하면 2가지 선택지가 있다. 해당 검색어에 해당하는 결과가 하나뿐인 경우는 해당 결과로 위치 검색을 종료한다. 결과가 여러 개인 경우 다시 한번 상세 검색을 띄운다.

![location-search](https://user-images.githubusercontent.com/17468015/173227973-4daf7840-bc63-47f8-abfd-f4dd029a82c8.gif)

# 리팩토링

## 개요

했던 리팩토링 작업을 요약하면 3가지 파트로 나눌 수 있다.

1. ViewController에서 데이터 소스와 데이터 로딩 분리하기.
2. `UICollectionViewDelegate`를 DataSource에 합치기.
3. 객체 간 의존성 추상화하고 DI Container로 주입하기.

> 물론 실제로는 이렇게 깔끔하고 논리적으로 진행되지 않았다. 좌충우돌의 연속이었을 뿐... 하지만 설명을 위해서 다듬어봤다.


## 1. ViewController에서 데이터 소스와 데이터 로딩 분리하기

iOS MVC는 Massive View Controller라는 아주 오래된 농담이 있다. 

하지만 뷰 컨트롤러가 거대해지는 이유는 MVC의 문제가 아니다. 역할 분리에 신경을 쓰지 않았기 때문이다. 

MVP든, MVVM이든 다른 패턴이라도 역할 분리를 잘 하지 못하면 거대한 객체는 또 등장한다. 

맨 처음 구현한 위치 검색 기능은, 그야말로 전형적인 거대 뷰 컨트롤러였다. 

`LocationSearchViewController`라는 하나의 객체가 다음의 역할을 모두 하고 있었다.

- SearchBar, CollectionView에 대한 설정과 레이아웃 세팅
- CollectionView의 Delegate와 DataSource 역할
- MapKit API와 서버 API에서 데이터 불러오기.

> **자, 이제 거대 뷰 컨트롤러를 해체해보자!**

![tuna](https://cdn.isusanin.com/news/photo/201701/28481_7258_2417.jpg)
(출처: 수산인신문)

### 1. DataSource, Delegate 분리

위치 검색 기능을 담당하는 `LocationSearchViewController` (이하 VC) 는 `UICollectionView` (이하 컬렉션 뷰)를 가지고 있다. 

컬렉션 뷰는 데이터를 띄우거나 인터랙션이 있을 때 `UICollectionViewDataSource` (이하 DataSource)와 `UICollectionViewDelegate`(이하 Delegate)에 무엇을 해야할지 물어본다. 

현재는 VC가 DataSource와 Delegate 메서드까지 직접 구현하고 있다.

![](https://velog.velcdn.com/images/eddy_song/post/e54d20a7-36a7-4841-8d02-4a8bbab16a7b/image.png)

이 두가지 역할을 별도 객체로 분리해보자. 

**DataSource를 역할별로 분리하기.**

DataSource를 분리하는 것은 단순한데, 그 안에도 복잡한 부분이 있었다.

위치 검색은 처음에는 추천 장소를 보여주다가, 검색이 시작되면 검색 키워드를 보여준다. 그리고 상세 검색 때는 상세 검색 데이터를 보여준다.

기존의 DataSource 메서드는 이 변화를 조건문으로 처리하고 있었다.

```swift
func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
    if isSearching{
        return searchResultData.count
    }
    return recommendationData.count
}
```

`isSearching` 이라는 변수를 사용해서 셀의 갯수를 지정했다.

`isSearching`은 검색 바 입력 처리에서 바꿔주는 `Bool` 값이다. 처음에는 이런 식의 코드였다. 

```swift
func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
		if searchText == "" {
		    isSearching = false
		    searchResultData.removeAll()
		    collectionView.reloadData()
		}
		else {
		    isSearching = true
		    searchCompleter.queryFragment = searchText
		}
}
```

조건문을 사용하면 기능이 추가될 때 코드를 수정해야한다. 좋지 않은 방법이다. 

또 각 단계별로 Datasource를 분리해서 역할을 더 뚜렷하게 만들 필요가 있었다.

추천, 자동완성, 상세검색을 모두 별도의 DataSource로 분리했다. 

아래는 추천 데이터를 담당하는 `RecommendationDataSource` 객체다.


```swift
class RecommendationDataSource: NSObject, UICollectionViewDataSource {

    private var recommendationData = [Place]()
    private var didLoadData: () -> Void

    init(didLoadData: @escaping () -> Void) {
        self.didLoadData = didLoadData
        super.init()

        let location = Location.makeRandomInKR()
        let recommendator = DefaultRecommendator()

        recommendator.recommend(for: location) { place in
            guard let place = place else { return }
            self.recommendationData = place
            didLoadData()
        }
    }

    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        recommendationData.count
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: PlaceCell.reuseIdentifier, for: indexPath) as? PlaceCell else { return UICollectionViewCell() }
        let data = recommendationData[indexPath.item]
        cell.setPlaceCell(data)
        return cell
    }
}
```

이런 식으로 DataSource를 총 3개로 분리했다. 

응집도가 훨씬 높은 객체를 만들 수 있었다. 추천, 자동완성, 최종 검색 각 단계에 따라서 서로 완전히 다른 인스턴스 변수를 참조하기 때문이다.

![diagram_1](https://raw.githubusercontent.com/adnpark/daily-devlog/f0abac63dec4c01144b872613ab174ca84e64a2b/eddy/separate_datasource.png)

이제 상위 VC는 이벤트(검색 시작, 장소 선택)에 따라 서로 다른 Datasource를 갈아끼운다. 하나의 콜렉션뷰를 재활용하면서도, 데이터를 채우는 역할은 분리했다.

마찬가지로 Delegate도 분리했다. Delegate는 Cell에 대한 터치가 들어왔을 때 이벤트를 처리한다.  

그런데 Delegate 분리는 문제가 발생했다. 깔끔했던 DataSource 분리와 달랐다. 여기에 대해 다음 챕터에 다시 설명하도록 하자.

### 2. 데이터 로딩 모델 분리

각 DataSource는 외부에서 데이터를 불러온다. 추천 데이터는 **서버 API**, 자동완성과 검색 결과는 **MapKit API**를 사용한다.

현재 코드는 DataSource가 직접 MapKit과의 소통과 네트워크 요청을 처리하고 있었다.

어떻게 하고 있었을까? 아래 코드를 보자.

```swift
import UIKit
import MapKit

class SearchCompletionDataSource: NSObject, UICollectionViewDataSource {

    private var searchResultData = [MKLocalSearchCompletion]()
    private var searchCompleter = MKLocalSearchCompleter()
    private var didLoadData: () -> Void

    init(didLoadData: @escaping () -> Void) {
        self.didLoadData = didLoadData
        super.init()
        searchCompleter.delegate = self
    }

	// (...) Datasource 관련 메서드 생략

	// 검색어를 MKLocalSearchCompleter에게 알려준다.
    func setQueryFragment(_ queryFragement: String) {
        searchCompleter.queryFragment = queryFragement
    }
}

extension SearchCompletionDataSource: MKLocalSearchCompleterDelegate {
	// MKLocalSearchCompleter는 자동완성 결과를 delegate로 전달한다.
	// Datasource는 결과를 인스턴스 변수에 저장하고, 상위 객체에 로딩 완료를 알린다.
    func completerDidUpdateResults(_ completer: MKLocalSearchCompleter) {
        searchResultData = searchCompleter.results
        didLoadData()
    }
}
```

DataSource 역할이면서, 외부 API에 데이터를 요청하는 역할을 같이 하고 있다. 

객체 역할을 더 작게 쪼개고 싶어서 데이터 로딩 부분을 분리해냈다.

이쯤 되면 약간 고민이 되기 시작한다. 정말 이 역할을 꼭 분리해야하는가?

사실 누구나 '단일 책임 원칙'을 안다. 한 객체가 한 역할만 하게 해야한다. 

그런데 어디까지가 하나의 역할인가? 그건 보는 사람마다 다르다. Data를 요청해 받아오는 로딩(Loading)과, View에 전달해주는 소싱(Sourcing)은 별도 역할이라고 봐야할까?

어쩌면 지나친 분리일 수도 있겠다 싶었다.

또 하나 고민해본 옵션이있다. DataSource를 컨트롤러 객체가 담당하지 않고, 모델 계층이 담당하도록 하면 어떨까?

ViewController에서 분리해놓고 보니 Datasource는 모델과 거의 비슷한 역할을 한다는 생각이 들었기 때문이다.

> DataSource는 사실 모델에 가깝지 않은가?

하지만 리서치 결과 그게 아니라는 사실을 알았다. DataSource는 TableView, CollectionView에 데이터를 채우는 역할이다. 자연스럽게 `UIKit`에 의존한다. `UITableViewCell` 같은 타입 정보를 알아야 한다. 다시 말해, `import UIKit`이 들어갈 수밖에 없다.

MVC 패턴에서는 뷰와 모델의 관심사를 분리해야한다는 원칙이 있다. 모델은 UIKit에 완전히 독립적이어야 한다.

현재는 기능이 단순하기 때문에 데이터 소싱과, 데이터 로딩을 같이 하는 게 이상해보이지 않는다. 하지만 장기적으로 일관성 있는 계층 구조를 유지하기 위해서는 둘의 분리가 필요하다는 결론이 나왔다.

Data를 요청해 받아오는 로딩(Loading)과, View에 전달해주는 소싱(Sourcing)을 별도 역할로 분리했다. 

'컨트롤러' 계층에 속하는 DataSource 객체와 '모델' 계층에 속하는 Data Loading 객체로 분리했다. 

이제 DataSource는 데이터를 저장하지 않는다. 모델에게 요청해서, 뷰로 전달해줄 뿐이다.

![diagram_2](https://raw.githubusercontent.com/adnpark/daily-devlog/f0abac63dec4c01144b872613ab174ca84e64a2b/eddy/separate_dataloading.png)

### ⚠️ Value type을 캡처하는 클로저 

이 때 한 가지 문제가 발생한다.

데이터 로딩 모델은 `struct`로 만들었다. `struct`는 value type이 된다. value type은 불변성 덕분에 부수효과가 발생하지 않고, Stack에서 다루기 때문에 효율적이다. 

별다른 이유가 없으면 기본적으로 value type으로 타입을 정의해준다.

여기에 데이터를 비동기로 요청하는 메서드를 추가했다. 완료되면 자신의 인스턴스 변수에 저장한다.


![error_1](https://raw.githubusercontent.com/adnpark/daily-devlog/f0abac63dec4c01144b872613ab174ca84e64a2b/eddy/mutating_self_error.png)

탈출 클로저는 self 파라미터를 캡처할 수 없다는 에러가 뜬다. 

우리는 `getRecommendation()` 이라는 함수에 인자로 클로저를 넘긴다. 

탈출 클로저는 해당 스코프가 끝난 뒤에 나중 어떤 시점에 실행된다. 그때 이 클로저는 받아온 데이터를 저장하기 위해 DefaultRecommendator 모델을 기억(캡처)한다.

> 탈출 클로저가 Value type을 캡처하고 있다.

Value type은 할당 시 참조가 아닌 값 전체를 복사한다. 클로저가 value type을 캡처하면 복사가 일어난다.

클로저 안에 캡처되는 `DefaultRecommendator` 인스턴스는 실제 클로저를 파라미터로 넘기는 `DefaultRecommendator`  인스턴스와 '다른' 인스턴스다.

따라서 나중에 이 `DefaultRecommendator`를 찾아와서 값을 저장해준다는 게 말이 되지 않는다. 

에러는 이 말을 하고 있었다.

특정 스코프가 완료(return)된 후에 목표한 데이터에 접근하려면 어떻게 해야할까? 

**참조 타입(Reference type)으로 만들어줘야 한다.** 참조 타입은 힙에 저장되고 참조가 복사된다. '고유성'을 갖는다. 다른 스코프에서도 식별가능하다.

데이터를 참조 타입으로 만드는 방법은 2가지가 있다.


1. 데이터를 요청하는 `DefaultRecommendator` 타입을 `class`로 바꾸는 것
2. `DefaultRecommendator`의 프로퍼티이자 데이터를 저장하는 `recommendationData`를 `class`로 감싸는 것

첫번째 방법이 가장 단순해보인다. 가장 먼저 떠오르는 해결책이다. 

> struct로 하니까 안 된다고? 그럼 class로 바꿔.

하지만 여기서 우리가 클로저에서 캡처하고자 하는 목표는 `DefaultRecommendator`가 아니라 변수인 `recommendationData`다.

물론 1번으로 문제는 해결할 수 있다. 
`DefaultRecommendator`가 `recommendationData`를 갖고 있다. `DefaultRecommendator`를 `class`로 바꿔 Heap에 저장되게 한다. `recommendationData`도 자연스럽게 힙에 저장된다. 

하지만 참조 타입의 단점인 부수효과(Side effect)의 범위가 '필요 이상으로' 넓어진다. 

만약 `DefaultRecommendator`에 또다른 인스턴스 변수가 존재한다면, 그 데이터도 레퍼런스 타입이 된다. 우리는 가급적 Value type을 많이 쓰고 싶다!

예측가능성, 스레드안전성, 테스트 용이성 등 Value type이 가지는 장점을 유지하기 위해서다. 

따라서 Reference type이 되는 범위, 부수 효과가 생기는 범위는 가급적 최소화하는 게 좋다. 

2번째 방법을 선택하자.

`recommendationData`는 배열이다. 배열(Array)은 값 타입이다. 참조 타입으로 바꾸기 위해 값을 감싸는 별도의 객체를 만들어줘야 한다.

이 객체 이름을 `Box`라고 하자.

```swift
class Box<T> {
    init(value: T) {
        self.value = value
    }

    var value: T
}
```

`Box`는 참조 타입이다. 클로저는 참조를 캡처한다. 나중에 요청한 함수 스코프가 종료된 후에도 데이터 응답을 넣어줄 수 있다.

동시에 `DefaultRecommendator` 타입은 `struct`로 그대로 유지할 수 있다.