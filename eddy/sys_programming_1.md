# System Programming

## 시스템 프로그래밍 VS 애플리케이션 프로그래밍

- 사실상 대부분의 개발자들은 애플리케이션 프로그래밍을 한다.
- 자바, 파이썬, 자바스크립트 같은 엉어들은 상위 레벨로 이동해서 애플리케이션 프로그래밍을 한다.
- 시스템 소프트웨어는 다른 (애플리케이션) 소프트웨어에게 서비스를 제공한다.
- 예를 들면, 아파치 웹서버, Vim이나 Emacs 같은 편집기, bash 쉘, gcc, ls 등이 있다.
- 시스템에서 제공하는 시스템 호출을 이용해 프로그램을 작성하는 것이다.
- 일반적인 애플리케이션 프로그래밍에서는 시스템 호출을 직접 하지 않는다.

## 시스템

‘시스템’은 하나의 목적을 달성하기 위한 하드웨어, 소프트웨어 자원을 묶어놓은 것이다.

## 시스템 콜

리눅스 운영체제가 제공하는 서비스를 생각해보자.

리눅스는 파일 시스템 접근, 사용자, 시스템 정보. 네트워킹 등 다양한 서비스를 제공한다.

**시스템 호출(System Call)**은 서비스를 이런 API로 제공한다.

시스템 콜을 통해 운영체제에게 요청을 하고, 하드웨어의 서비스를 애플리케이션에게 전달한다.

운영체제 (시스템 프로그램)이 제공하는 기능을 사용하기 위한 수단이다.

시스템 호출은 C 언어의 함수 형식이다. 호출명은 함수명처럼 사용할 이름이 정의돼있다. 

시스템 호출은 대부분, 호출의 성공이나 실패값을 알려주는 정수를 return한다.

## 시스템 소프트웨어

운영체제만 가지고 프로그램을 만드는 것은 쉬운 일이 아니다.

애플리케이션을 만들 때는 운영체제에 대고 직접 호출을 하면서 만드는 경우가 잘 없다.

대신 ‘자신이 시스템 호출을 직접 사용하되 다른 프로그램에게는 좀 더 쉽게 사용할 수 있는 추상화된 인터페이스를 제공하는 프로그램’을 사용한다.

이것을 시스템 소프트웨어라고 한다. 

어플리케이션과 운영체제를 중재해주는 유틸리티 역할을 한다.

## 시스템 프로그래밍

**시스템(을 구성하는 자원과 동작 원리)에 대해 이해**를 가지고하는 프로그래밍.

하위 시스템(자원)에 대한 이해가 있기 때문에 더 효율적인 프로그래밍을 할 수 있다.

## 라이브러리 함수

- 시스템 콜은 시스템 기능을 이용하는 통로다. 커널의 모듈을 직접 호출한다.
- 라이브러리 함수는 커널 모듈을 직접 호출하지 않는다.
- 라이브러리 함수는 시스템 콜을 사용해서 시스템을 다룬다. 시스템 콜을 사용해서 구현한 함수를 미리 컴파일해둔 것이다. 라이브러리 함수가 내부적으로 시스템 콜을 한다.
- 간접적으로 하나의 코드에 하나의 층이 추가된다고 할 수 있다.
- 자주 사용되는 기능을 구현해놓고 불러서 쓸 수 있다.
- 시스템 호출과 라이브러리 함수는 다른 것이지만, 사용 방법은 크게 다르지 않다.

## C 라이브러리

C 라이브러리 (libc) 는 유닉스 애플리케이션의 핵심이다. 최신 리눅스에서는 GNU C 라이브러리를 쓰는데 지립씨라고 읽는다.

## C 컴파일러

리눅스는 표준 C 컴파일러로 gcc를 사용한다. 

C 언어로 된 소스코드를 컴파일해서 컴퓨터에서 실행할 수 있는 기계어 파일로 만드는 소프트웨어다. 보통 컴파일에는 컴파일과 외부 라이브러리를 링크하는 과정까지를 포함해서 통칭한다.

## 시스템 프로그래밍의 3가지 주춧돌

1. 시스템 콜
2. C 라이브러리
3. C 컴파일러

## 왜 시스템 프로그래밍을 배워야 하는가?

- 더 효율적으로 프로그램을 구현할 수 있다. (중간 과정이 없기 때문에)
- 시스템 자원에 대한 이해가 높아진다. (파일, 프로세스, 시그널, 통신 인터페이스 등)

---

# 유닉스, 리눅스 운영체제 표준과 역사

## UNIX

유닉스는 AT&T 벨 연구소에서 켄 톰슨과 데니스 리치가 개발한 운영체제다. 유닉스는 처음에 어셈블리로 개발했지만, 데니스 리치가 만든 C 언어로 다시 만들었다.

유닉스는 (윈도우를 제외한) 현대 대부분 운영체제의 조상이라고 할 수 있다. 여러 계열로 나누어 발전했다.

먼저, 버클리 계열(Berkeley Software Distribution, BSD)이 있다. 나중에 넥스트 스텝, 그리고 MacOS와 iOS로 진화했다.

그 외에 상업용 유닉스인 `System V` 계열도 있다.

## Linux

또다른 중요한 계보는 **리눅스 쪽**이다. 유닉스 계열 운영체제이면서 교육 목적으로 제작된 미닉스(Minix)가 먼저 있었다.

리눅스는 그 유명한 리누스 토르발즈가 이 미닉스에서부터 만들었다. 리눅스는 리누스의 유닉스(Linus Unix)의 줄임말이다. 리눅스는 계속 발전해서 원탑 운영체제가 되었으며, 안드로이드가 리눅스 기반이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d56c45fc-b2cb-44d2-85a1-380257a6a70d/Untitled.png)

## C 언어 표준: ANSI

ANSI는 미국 표준협회다. ANSI가 정의한 표준이 C 언어의 국제 표준이다. C 언어의 문법, 라이브러리 , 헤더 파일을 정의한다. 

## 시스템 인터페이스 표준: POSIX & SUS

## POSIX

‘파직스'라고 읽는다. 유닉스 기반의 운영체제 인터페이스다. 유닉스 시스템의 공통적인 API를 정의한 표준이다. Portable Operating System Interface X

아까 말했듯이 유닉스에서 나온 운영체제는 매우 많다. 하지만 다 다른 운영체제라고 하더라도, 넓게 봐서 파직스를 따르면 유닉스 호환, 유닉스 계열의 운영체제라고 부른다. 

리눅스는 유닉스와는 다른 운영체제지만, POSIX 표준을 따르기 때문에 유닉스 계열이라고 할 수 있음. 

맥OS도 마찬가지로 POSIX를 따른다. 

따라서 POSIX는 유닉스 가족의 최소 조건을 정의한다고 할 수 있음.

## SUS

Single Unix Specification.

진짜 ‘유닉스’라는 이름을 사용하려면 지켜야 하는 표준이다. 유닉스의 시스템 인터페이스 콜을 표준화하기 위한 노력이다. 

→ 파직스와 SUS는 가장 중요하고 영향력있는 2개의 시스템 표준이다. 

→ 워낙 유닉스라는 운영체제가 다양한 버전과 코드로 발전되어오다보니까 이런 표준을 정해서 개발자들이 배우거나 사용하기 쉽도록 만드는 것 같다.

→ 유닉스가 하나의 언어라고 생각하면 다양한 지역 사투리와 버전이 있고, 딱히 표준어라는 게 없다보니까, 나중에 표준말을 차차 정하게 된 것이다.

→ 1990년대 초반에는 유닉스 업체들이 서로 자신의 유닉스 버전을 표준 유닉스로 정의하려고 ‘유닉스 전쟁'을 치렀다고 한다. 우여곡절 끝에 ‘표준 유닉스’가 된 승자가 바로 POSIX와 SUS다.

→ 리눅스는 이 2가지 표준 POSIX, SUS를 따르려고 노력한다.

→ POSIX와 SUS를 기준으로 시스템 프로그래밍을 배우면 된다는 말인듯. SUS는 최신 POSIX를 포함한다.

시스템 인터페이스는 매우 절대적이고 변하지 않는 강력한 표준이어서, 리눅스 커널 개발자들은 아무리 구현을 바꾸어도 이 인터페이스를 바꾸지 않으려고 엄청난 노력을 기울인다.


# API와 ABI

## API

특정한 시스템 소프트웨어를 프로그래밍하면, 어떤 유닉스, 리눅스 운영체제에서든 잘 돌아가야 한다. → 호환성

시스템 호환성에 영향을 주는 2가지. API와 ABI가 있다.

**소스코드 호환성 - 시스템 콜의 함수명, 인자 등.**

API는 소스 코드의 호환성을 정의. API는 함수다. 상위 수준의 소프트웨어에서 하위 수준의 소프트웨어 함수를 호출한다. 예를 들어 C 라이브러리의 C API는 메모리 관리, 문자열 처리 같은 기본 함수를 정의하고 그걸 쓸 수 있게 해준다.

## ABI

**바이너리 (기계어) 호환성**

ABI는 소프트웨어 간의 바이너리 인터페이스를 정의한다. 

ABI는 특정한 바이너리가 어떤 아키텍처에서 실행될 수 있는지를 정의한다. 즉, 소스코드를 컴파일해서 만들어진 바이너리 파일이 같은 ABI를 지원하는 시스템이라면 동일한 기능을 수행한다. 

ABI는 하드웨어와 아키텍처에 큰 관련이 있으며, 아키텍처마다 다른 고유의 ABI를 가지고 있다.

ABI는 컴파일러, 링커 같은 툴체인에 의해서 강제 되므로 겉으로 드러나는 일은 거의 없다.

**(참고) CPU 아키텍처의 종류**

**`x64`** (Intel/AMD/Older Mac).**`AArch64`** (Mac M1) is the most popular for Personal Computer.

**`x64`**, **`ppc64`** and **`s390x`** are also considered widely spread.

`smartphones,` `tablets` : arm64


# 파일

파일은 유닉스에서 가장 기본적이고 핵심적인 추상화 개념.

“모든 것이 파일이다”

모든 인터랙션은 실제로 파일이 아닌 것처럼 보여도, 사실은 파일을 읽고, 파일에 쓰는 것으로 이루어진다.

파일로 다 취급하면 ‘동일한 툴과 API’로 다양한 자원을 다양한 방식으로 사용할 수 있기 때문이다.

즉 다시 말해 **‘사용 호환성’**을 위해서다. 유닉스의 철학 중에 하나다. 

`ls` `rm` 같은 명령어도 결국 하나의 파일이다. (`/bin` 안에 들어있다)

파일에 접근하려면 먼저 열어야 하고, 파일을 열 때 읽기 쓰기 모드를 지정할 수 있다.

**파일 디스크립터**

열린 파일에 대한 조작은 ‘파일 디스크립터'라는 것을 통해 할 수 있다. 어플리케이션이 파일에 접근할 때 파일 디스크립터를 사용한다. 

열려있는 파일을 구분해주는 정수 값이다.

0, 1, 2는 표준 입력, 표준 출력, 표준 에러로 미리 예약이 돼있다.

파일을 열 때 순차적으로 정수로 할당이 된다. 프로세스 당 최대 fd 수는 1024개가 기본이다.

리눅스 시스템 프로그래밍은 대부분이 파일 디스크립터를 조작하고 닫는 작업이다.

**리눅스의 3가지 파일**

1. 일반 파일
2. 디렉토리
3. 특수 파일

## 1. 일반 파일

연속된 바이트 배열을 바이트 ‘스트림’이라고 한다. 

스트림 안에 저장된 데이터가 파일이다.

파일을 위한 특별한 자료구조가 없다. 스트림 안에는 어떤 값을 넣어도 상관없고, 어떤 구조로 상관없다. 

리눅스는 바이트 스트림 외에 어떤 자료구조도 강제하지 않는다. 다른 운영체제에서는 고도화된 자료구조를 제공하지만 리눅스는 단순한 바이트 스트림만 사용한다.

파일에 바이트를 읽고 쓸 수 있다. 파일 내부에 데이터를 저장하는 위치는 파일 오프셋, 파일 위치라고 한다.

커널은 열려있는 파일마다 파일 오프셋을 저장해놓는다. 맨 처음 파일이 열리면 오프셋은 0이다. 오프셋은 보통 바이트 단위가 된다. (배열 조작과 비슷한 것 같다.)

파일을 쓰는 작업 대부분은 파일 끝에서 일어난다. 

파일의 크기는 바이트 단위로 측정된다. 바이트 배열의 크기다. 

하나의 파일은 여러 프로세스에서 열 수 있다. 동일한 프로세스에서 2번 여는 것도 가능하다. 열 때마다 고유한 파일 디스크립터 (참조)를 반환한다. 

프로세스들끼리 동일한 파일 디스크립터를 공유할 수도 있다. 파일에 대한 동시접근도 가능하다. 하지만 파일 동시 접근을 하면 각각의 순서에 따라서 일관성 없는 결과를 만들고, 예측이 불가능해진다. 유저 스페이스에서는 동시 접근을 하지 않도록 신경써야 한다.

## i-node

파일은 i-node라고 하는 파일 시스템 내의 정수로 참조된다. i-node 번호라고 부른다. i-node는 파일의 변경된 날짜, 타입, 길이, 위치 같은 메타 데이터를 저장하고 있다. 

## 2. 디렉터리

→ 링크를 저장한 파일

하지만 i-node 번호로 파일에 접근하는 것은 귀찮고 보안 문제도 있다. 사용자가 파일을 사용할 때는 i-node가 아니라 파일 이름으로 접근한다. 

이름과 inode를 연결한 쌍을 링크라고 한다. 

디렉터리는 inode와 파일명의 쌍(링크)을 저장하는 파일이다. 디렉터리에서 파일명을 매핑하고 있기 때문에 특정한 파일을 열 수 있다. 

디렉토리 자체도 파일이다. 따라서 디렉토리는 i-node를 가진다. 디렉토리의 이름과 i-node는 상위 디렉토리에 저장된다. 계층 구조를 형성할 수 있게 된다.

따라서 루트 디렉토리부터, `/home/black/bird.png` 같은 파일 경로를 생성할 수 있게 된다.

특정한 파일 경로를 열어달라고 커널에 시스템 콜을 한다. 커널은 파일 경로에서 home을 가리키는 i-node를 찾는다. 그 i-node에서 black을 가리키는 i-node를 찾고, 최종적으로 bird.png를 찾는다.

루트 디렉터리에서 시작하는 경로 이름은 완전한 형태이기 때문에 절대 경로라고 한다.

완전한 형태가 아니라 디렉터리의 상대적인 위치로 나타내면 상대 경로라고 한다. 상대 경로는 현재 디렉터리를 기준으로 탐색해서 파일을 찾는다. 

상대 경로 + 현재 경로를 합치면 절대 경로가 된다.

디렉터리는 파일처럼 취급하지만 파일처럼 조작하지는 못한다.  디렉터리에는 특정한 API만 제공되는데 파일에 링크를 추가하거나, 삭제하는 등이다. (디렉터리를 건드렸다가 파일 시스템 전체를 망가뜨릴 수 있기 때문이다.)

## 하드 링크

여러개 링크가 동일한 i-node를 매핑하고 있을 때.

하나의 i-node에 파일 명이 여러개일 때, 하드 링크라고 한다.

하드 링크들은 각각 다른 디렉터리에 존재할 수 있다.

디렉터리에서 파일을 삭제하면 해당 디렉터리에서 링크를 삭제한다. 하지만 링크를 삭제할 때 만약 다른 하드 링크가 남아있을 가능성이 있다. 파일 시스템 안에는 링크의 갯수를 세는 카운터가 있다. 특정 i-node에 더 이상 링크가 존재하지 않는다면, i-node와 실제 파일을 삭제한다.

## 심벌릭 링크

inode는 하나의 파일 시스템에서만 유효하다. 여러 파일 시스템에서 사용할 수 있는 링크는 심벌릭 링크다. 심벌릭 링크는 일반 파일처럼 생겼는데, 그 안에 실제 가리키는 파일의 링크를 가지고 있다. 

## 3. 특수 파일

리눅스는 4종류의 특수 파일을 지원한다.

## 1. 블록 디바이스 파일

- 하드웨어 장치도 파일을 통해 접근한다.
- 디바이스 파일은 일반 파일처럼 생겼고, 동작한다.
- 디바이스 파일을 열고, 읽고 써서 하드웨어 장치를 조작할 수 있다.
- 하드웨어 장치에는 블록 디바이스와 캐릭터 디바이스가 있다.
- 블록 디바이스는 큐가 아닌 배열로 접근한다. 특정한 위치의 값을 읽을 수 있다. 임의 접근. 랜덤 액세싱이 가능하다.
- 블록 디바이스는 보통 저장장치다. 하드 디스크, CD-ROM, 플래시 메모리 등이다.
- 블록 디바이스는 ‘블록 디바이스 파일'이라는 특수 파일로 접근한다.

## 2. 캐릭터 디바이스 파일

- 캐릭터 디바이스는 선형적으로 이뤄진 큐다. 하드웨어를 관리하는 **디바이스 드라이버**가 큐에 바이트를 하나씩 집어넣는다.
- 사용자 영역에서는 큐에 쌓인 순서 앞에부터 바이트를 읽어낸다.
- 키보드가 캐릭터 디바이스의 대표적인 예다.
- 캐릭터 디바이스는 ‘캐릭터 디바이스 파일'이라는 특수 파일로 접근한다.

## 3. 네임드 파이프

- 네임드 파이프는 IPC 메커니즘이다. 다른 프로세서와의 통신 채널을 제공하는 특수 파이프다.
- 일반 파이프는 FIFO라는 특수한 파일을 거쳐 접근한다.
- 서로 다른 프로세스가 이 파일에 접근해서 프로세스 간 통신을 한다.

## 4. 유닉스 도메인 소켓

- 소켓은 다른 프로세스끼리 통신할 수 있는 IPC의 한 종류다.
- 같은 기계가 아닌 다른 기계끼리도 통신이 가능하다.
- 소켓은 인터넷, 네트워크의 근본이다.
- 유닉스 도메인 소켓은 로컬 머신 내부에서 프로세스끼리 통신하는 소켓이다.
- 인터넷에서 통신하는 소켓과는 약간 다르다.
- 유닉스 도메인 소켓은 특수 파일인 소켓 파일을 사용한다.

## 파일을 읽고 쓰기 (입출력)

- 저수준 파일 입출력 (시스템 콜)
    - 파일 디스크립터 사용.
    - 바이트 단위로 읽고 쓴다.
    - 특수 파일에 대한 입출력 가능.
- 고수준 입출력 (Buffered IO, C 라이브러리 사용)
    - 파일 포인터 사용. 버퍼(블록) 단위로 읽고 쓴다.

## 파일 시스템, 네임스페이스

- 윈도우에서는 플로피 디스크는 `A:/plank.jpg`  하드 디스크는 `C:/media/plank.jpg` 등으로 네임스페이스를 따로 구분해놓는다.
- 하지만 유닉스에서는 외부 장치에 있는 파일 경로도 네임스페이스가 모두 통합돼있다.
- 파일 시스템은 각 장치별로 가지고 있을 수 있지만, 이것을 전역 네임스페이스 안에 ‘마운트' 시킬 수 있다.
- 마운트 시킨 포인트가 루트 경로가 되어 접근할 수 있다.
- 이 때 리눅스의 가장 기본이 되는 파일 시스템을 루트 파일 시스템이라고 하고, 다른 파일 시스템들은 이 루트 파일시스템에 ‘마운트'해서 사용한다.
- 보통 파일 시스템은 물리적으로 나뉘어져있다. CD, 하드디스크, SD카드 등의 저장 매체별로 파일 시스템이 있다. 하나의 저장 매체 안에 파티션을 나눠서 파일 시스템을 2개 이상으로 사용하는 경우도 있다.
- 블록 디바이스를 물리적으로 접근하는 단위는 ‘섹터'다.
- 파일 시스템에서 논리적으로 접근하는 단위는 ‘블록'이다.
- 블록은 추상화된 개념으로 물리 매체와는 무관하다. 블록은 섹터 크기 곱하기 2의 배수이다.
- 블록은 섹터보다는 크지만, 메모리의 페이지보다는 작다.
- 리눅스는 프로세스별 네임스페이스를 지원한다. 각 프로세스는 루트의 네임스페이스를 상속받지만, 프로세스는 별도의 독자적인 네임스페이스를 만들 수 있다.

# 프로세스

프로세스는 실행 중인 ‘오브젝트 코드’다. = 실행 중인 프로그램이다.

먼저, 커널이 이해하는 실행 파일 포맷을 갖춘 ‘실행 가능한 오브젝트 코드’가 있다. 프로세스는 이 오브젝트 코드에서 시작된다. 

리눅스의 실행 파일 포맷은 ELF다. (윈도우는 exe) 

실행 파일은 여러 섹션으로 나눠져있다. 실행 파일에서 가장 중요한 섹션은 text, data, bss다. 

- text에는 실행 가능한 코드, 상수, 변수와 같은 읽기 전용 데이터가 들어간다.
- data 섹션에는 변수의 초기값이 들어있다.
- BSS 섹션은 초기화되지 않은 전역 데이터가 들어있다.

프로세스는 시스템 콜을 사용해서 리소스를 요청하고 조작한다. 

프로세스와 관련된 여러 정보는 프로세스 디스크립터의 형태로 커널 내부에 저장된다.

프로세스는 가상화를 위한 추상 개념이다. 운영체제는 가상화된 프로세서와 가상화된 메모리를 제공한다. 

**프로세스는 마치 혼자서 시스템을 통제하고 있다는 착각에 빠진다. (*이 부분이 항상 이해가 잘 안됨. 프로세스가 착각을 하고 있다는 게 무슨 말일까? 왜 이렇게 하는 걸까?)**

프로세스가 여러개 실행돼도 프로세스 각각은 전체 시스템을 독점하듯이 사용한다.

커널은 모든 프로세스가 적절하게 프로세서를 쓸 수 있도록 잘 분배한다.

커널은 각 프로세스에 물리적 주소 위에 매핑한 단일한 주소 공간을 제공한다. 커널은 가상 메모리와 페이징 기법을 사용한다. 프로세스마다 다른 주소 공간을 사용하도록 만든다. 여러 프로세스가 시스템 상에 공존할 수 있다. 

## 스레드

프로세스는 하나 이상의 스레드를 가진다. 

프로세스에 하나의 스레드만 있으면 싱글 스레드, 여러 스레드가 있으면 멀티 스레드라고 한다. 

스레드는 명령어의 현재 위치를 저장하는 레지스터와 지역 변수를 저장하는 스택으로 이뤄져있다.

리눅스 커널은 독특한 관점으로 스레드를 구현한다.

리눅스에서 스레드는 프로세스다.  **‘리소스를 공유’하는 일반적인 ‘프로세스'일 뿐이다.**

## 프로세스의 계층 구조

프로세스는 `pid` 라고 하는 고유한 숫자가 있다. 1부터 시작된다.

리눅스의 프로세스는 프로세스 트리라는 엄격한 계층 구조를 형성한다.

‘init 프로그램’ 이라는 프로세스가 루트다.

새로운 프로세스는 `fork()` 라는 시스템 콜로 만들어진다.

시스템 콜을 호출한 프로세스를 복사해서, 다른 프로세스를 만든다.

원본 프로세스는 부모이고, 복사된 프로세스는 자식이다. 

init 프로세스를 제외한 모든 프로세스는 부모가 있다. 

부모 프로세스가 종료되면 시스템에서 바로 제거되지 않는다. 자식 프로세스도 종료될 때까지 기다린다. 부모 프로세스가 종료되었는데 자식 프로세스도 같이 종료되면 자식 프로세스는 완전히 종료된다.

## 사용자와 그룹

리눅스에서 권한을 제공받는 주체는 사용자, 혹은 그룹이 있다.

사용자는 `uid` 라고 하는 고유한 숫자를 하나씩 부여받는다.

프로세스마다 자신을 실행하는 사용자의 `uid`를 저장한다.

리눅스에서 사용자 로그인을 하면, 로그인 프로그램은 사용자 로그인 셸을 실행해서 셸의 uid를 사용자 uid로 바꾼다.

uid 0은 루트 사용자다. 루트 사용자는 강력한 권한을 가지고 있다.

모든 사용자는 **‘그룹’** 에 속한다. 프로세스마다 gid가 대응되어, 실제 gid, 유효 gid, 저장된 gid, 파일시스템 gid를 갖게 된다. 

## 권한

리눅스의 파일 접근 권한은 3가지 비트가 있다.

각 비트는 소유자, 소유자 그룹, 그 외 사용자가 파일을 읽고, 쓰고, 실행하는 능력을 기술한다. 3 그룹별로 권한을 나타내는 비트가 3개니까 3X3 으로 총 9비트로 표현한다.