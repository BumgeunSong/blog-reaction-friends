# 1. 시스템 프로그래밍 - 핵심 개념 소개

## 궁금증 🤔

- 시스템 프로그래밍의 정의가 다양하다. 시스템 소프트웨어를 프로그래밍하는 것 = 시스템 프로그래밍일까?
- Vim이나 Emacs 같은 애들이 시스템 소프트웨어라고 한다. 비슷한 기능인 워드프로세서도 시스템 소프트웨어인가? 에디터도 결국 최종 사용자는 사람인데, 시스템 소프트웨어인가?
- ‘시스템’은 운영체제(오퍼레이팅 시스템)과 같은 개념이라고 봐도 되는가?
- 왜 시스템 프로그래밍을 배워야 하는가?
- iOS와 리눅스는 어떤 점이 다르고 어떤 점이 같을까?
- 다른 언어는 표준이란 걸 들어본 적 없는데 왜 C는 별도의 표준이 있지?
- C 언어가 아닌 다른 언어로 시스템 프로그래밍을 할 수는 없는가? 그럼 그때는 시스템 콜을 어떻게 쓰지?
- SUS에 POSIX가 포함되어있다고 하는데 그러면 SUS 하나만 알면 되는 거 아닌가?
- 리눅스는 파일 시스템의 네임스페이스와 다른 프로세스별 독자적인 네임스페이스를 만들 수 있다고 하는데, 이게 무슨 뜻일까?

# 목차

---

# 시스템 프로그래밍이란 무엇인가?

**정의 1. 애플리케이션 소프트웨어가 아닌 시스템 소프트웨어를 프로그래밍하는 것.** 

- 시스템 프로그래밍은 애플리케이션 프로그래밍과 비교하면 쉽다.
- 소프트웨어는 시스템 소프트웨어와 애플리케이션 소프트웨어로 나뉜다.
- 시스템 소프트웨어는 운영체제, 커널에서 제공하는 저수준 기능을 활용해서 다른 소프트웨어에게 추상화(단순화)된 서비스를 제공한다.
- 시스템 소프트웨어는 응용 프로그램이 하드웨어를 사용할 수 있도록 추상화를 제공한다. 어플리케이션과 운영체제를 중재해주는 유틸리티 역할이다.
- 시스템 소프트웨어에 운영체제가 포함된다.
- 그 외에도 아파치 웹서버, Vim, Emac 같은 코드 에디터, 쉘, C 컴파일러, ls (디렉토리 관리) 등이 시스템 소프트웨어다. 아파치 웹서버, Vim이나 Emacs 같은 편집기, bash 쉘, gcc, ls, 장치 드라이버, mySQL 같은 DBMS.
- 대부분의 개발자들은 애플리케이션 프로그래밍을 하고, 자바, 파이썬, 자바스크립트 같은 고수준의 언어를 사용해서 프로그램을 작성한다.
- 이런 애플리케이션들은 보통 일반 사용자들이 사용하는 목적으로 개발한다.

**정의 2. 커널이 제공하는 서비스를 직접 사용해서 프로그래밍을 작성하는 것.**

- 보통 이런 애플리케이션 프로그래밍에서는 시스템 호출을 직접 하지 않는다.
- 대신 컴파일러와 같이 시스템 호출을 사용하는 시스템 소프트웨어를 사용한다.
- 왜냐하면 운영체제 API만 가지고 원하는 프로그램을 만드는 것은 어려운 일이기 떄문이다.
- ‘자신이 시스템 호출을 직접 사용하되 다른 프로그램에게는 좀 더 쉽게 사용할 수 있는 추상화된 인터페이스를 제공하는 프로그램’을 사용한다.
- 시스템 프로그래밍에서는 직접 '시스템 콜'을 사용해서 하드웨어 자원을 조작하는 프로그램을 작성한다.

**정의 3. 시스템 자원과 동작 원리를 이해하면서 프로그래밍하는 것.**

- low-level 시스템에 대한 이해가 있기 때문에 더 효율적인 프로그래밍을 할 수 있다.

# 사용자 영역에서 커널을 사용하는 방법 (시스템 콜, 라이브러리 함수, 쉘)

## 시스템 콜이란 무엇인가?

- 운영체제는 프로세스 제어, 파일 조작 등 다양한 서비스를 제공한다.
- 운영체제가 제공하는 이런 서비스를 사용할 수 있는 API가 바로 시스템 콜이다.
- 말 그대로 시스템을 불러서 작업을 요청할 수 있다는 것.
- 일반적으로 프로세스가 작동하는 '사용자 모드'에서는 커널 영역의 기능을 직접 사용할 수 없다.
- 파일이 필요하거나, 프로세스를 만들어야 하는 상황이라면 커널에게 요청을 해야 한다.
- 시스템 콜을 하게 되면 일시적으로 제어권이 '커널'로 넘어가게 된다. 커널은 요청받은 작업을 수행한 후에 다시 프로세스로 제어권을 넘겨준다.
- 이런 시스템 콜의 주요 카테고리는 5개 정도다.
    - 1. 프로세스 제어
        - fork(), signal()
    - 2. 파일 조작
        - open(), read()
    - 3. 장치 관리
        - brk()
    - 4. 정보 유지
        - time()
    - 5. 통신
        - socket() bind() connect()
- 각 시스템 콜은 커널이 알아들을 수 있도록 고유한 번호가 매겨져있다. 하지만 시스템 콜을 사용할 떄는 C언어 함수처럼 사용한다. 함수명에 인자를 넣어서 처리한다.

## 라이브러리 함수란 무엇인가?

- 라이브러리 함수는 시스템 콜을 사용해서 구현한 함수를 미리 컴파일해둔 것이다.
- 시스템 콜은 커널 모듈을 직접 호출하지만, 라이브러리 함수는 직접 커널과 소통을 하지 않고, 시스템 콜을 통해서 작업을 한다.
- 커널을 사용할 때 하나의 추상화된 층이 더 추가된다고 이해할 수 있다.
- 시스템 호출과 라이브러리 함수는 다르긴 하지만, 사용방법은 비슷하다.

## 쉘이란 무엇인가?

- 쉘은 사용자가 직접 커널을 사용할 수 있게 해주는 커맨드 라인 인터페이스다.
- 프로그램을 짜서 안에 시스템 콜을 호출하고 실행시키는 대신에, 쉘에 단순한 명령어를 입력하면 쉘이 시스템 콜의 기능을 사용해서 작업을 수행한다.
- 쉘도 시스템 소프트웨어의 하나다. 리눅스의 표준 셸이 bash이다. GNU 프로젝트에서 개발했다. 그 외에 zsh, csh 등 다양한 쉘이 있다.

# 왜 C 언어인가?

- C 언어는 원래부터 시스템 프로그래밍용으로 태어난 언어이다. 운영체제 (UNIX)를 만들려고 만든 언어이기 때문이다. UNIX의 탄생은 1969년이고 그떄는 어셈블리어로 돼있었는데, 1972년에 C로 다시 작성됐다.
- C 언어는 운영체제와 매우 가깝고, 추상화가 많이 되어있지 않은 저수준의 언어이다. 예를 들어, 메모리를 직접 할당하고 관리해야 한다든지. 시스템과 하드웨어에 대해서 생각하면서 프로그래밍해야 한다.
- 유닉스 이후 대부분의 시스템 소프트웨어 (대부분의 운영체제)는 전부 C로 작성되었고, 시스템 프로그래밍에서는 거의 전세계 표준 언어이다.

## ANSI C

- C 언어 국제 표준은 ANSI C이다.
- ANSI는 미국 표준협회다. ANSI가 정의한 표준이 C 언어의 국제 표준이다. C 언어의 문법, 라이브러리, 헤더 파일을 정의한다.

## C 라이브러리

- C 언어에서 자주 사용하는 기본 코드를 미리 컴파일해둔 것이다. 최신 리눅스에서는 GNU C Library를 쓰는데 glibc(지립씨)라고 한다.

## 헤더 파일

- 헤더 파일은 (.h)은 외부 코드를 '링크'하는 과정에서 필요하다. 라이브러리는 이미 컴파일된 바이너리(기계어)이므로, 링크를 할 때 헤더 파일이 담아둔 변수, 상수, 타입 정보가 필요하다.

## C 컴파일러.

- C 언어 소스코드를 컴퓨터에서 실행할 수 있는 바이너리(기계어) 파일로 만드는 소프트웨어다. 보통 컴파일은 외부 라이브러리 링크 과정까지 포함해서 통칭한다.
- 리눅스는 표준 C 컴파일러로, gcc를 사용한다.

## 시스템 프로그래밍의 3가지 기둥

- <리눅스 시스템 프로그래밍>에서는 시스템 콜, C 라이브러리, C 컴파일러가 시스템 프로그래밍의 3가지 핵심이라고 한다.

# 왜 시스템 프로그래밍을 배워야 하는가?

(TBD)

- iOS 개발을 하면서 등장하는 문제의 발생 원인을 이해하고 디버깅을 잘 하기 위해서?
- 저수준의 시스템을 이해하고 효율적으로 프로그래밍하기 위해서?

# UNIX, LINUX란 무엇인가?

## 유닉스

- 유닉스는 현대 운영체제의 시조새같은 존재다.
- AT&T 벨 연구소에서 켄 톰슨과 데니스 리치가 개발한 운영체제다. 유닉스는 처음에 어셈블리로 개발했지만, 데니스 리치가 만든 C 언어로 다시 만들었다.
- 유닉스는 수정되고 개선되면서 여러가지 갈래로 뻗어나갔다.
- 그 중 중요한 계열은 버클리 계열이 있다. (Berkeley Software Distribution, BSD)이 있다. BSD는 나중에 넥스트 스텝, 그리고 MacOS와 iOS로 진화했다.
- 상업용 유닉스인 System V 계열도 있다. 썬(오라클), IBM등이 유닉스를 상업적으로 사용하기 위해 만든 버전이다.

## 리눅스

- 리눅스는 '유닉스 계열' 운영체제다. 하지만 유닉스와는 다른 운영체제다. 비슷한 인터페이스를 가진 사촌이라고 할 수 있다.
- 유닉스 계열 OS 중에서 Minix라는 게 있었는데, 이걸 그 유명한 리누스 토르발즈가 가져와서 바꿔서 만들기 시작한 게 리눅스다.
- (리눅스는 리누스의 유닉스라는 뜻)
- 리눅스는 계속해서 발전해서 현재 가장 널리 쓰이는 운영체제가 됐다.

# POSIX와 SUS란 무엇인가?

## POSIX (Portable Operating System Interface X)

- POSIX는 유닉스 시스템의 인터페이스를 정의한 표준이다.
- 워낙 유닉스에서 갈라져 나온 운영체제가 많아졌다.
- 유닉스 위에서 어플리케이션을 개발하는 사람들 입장에서는 운영체제마다 시스템 콜이 다르면 짜증이 날 것이다.
- 그래서 다양한 유닉스 계열 운영체제의 공통 분모를 모아서 표준인 POSIX가 탄생했다.
- POSIX를 따르면 유닉스 계열(Unix-like) 운영체제라고 부를 수 있다.
- BSD, Linux, macOS는 모두 POSIX를 따르는 운영체제다.

## SUS (Single Unix Standard)

- 1996년에 X/Open과 오픈 소프트웨어 파운데이션이 오픈 그룹으로 통합됐다.
- Open Group은 Unix의 상표권을 가지고 있는데, 이게 무슨 뜻이냐면 Unix라는 상표는 반드시 오픈 그룹이 제시한 규칙을 따라야지만 사용할 수 있다는 것이다.
- SUS는 최신 POSIX를 포함한다.

## 시스템 표준을 알아야 하는 이유

- 파직스와 SUS는 가장 중요하고 영향력있는 2개의 시스템 표준이다.
- 워낙 유닉스라는 운영체제가 다양한 버전과 코드로 발전되어오다보니까 이런 표준을 정해서 개발자들이 배우거나 사용하기 쉽도록 만드는 것 같다.
- 유닉스가 하나의 언어라고 생각해보자. 다양한 지역 사투리와 버전이 있고, 딱히 표준어라는 게 없다보니까, 나중에 표준말을 차차 정하게 된 것이다.
- 1990년대 초반에는 유닉스 업체들이 서로 자신의 유닉스 버전을 표준 유닉스로 정의하려고 ‘유닉스 전쟁'을 치렀다고 한다. 우여곡절 끝에 ‘표준 유닉스’가 된 승자가 바로 POSIX와 SUS다.
- 리눅스는 이 2가지 표준 POSIX, SUS를 따르려고 노력한다.
- POSIX와 SUS를 기준으로 시스템 프로그래밍을 배우면 된다는 뜻인 듯.

# API와 ABI란 무엇인가?

## API와 ABI는 둘 다 인터페이스다.

- 인터페이스는 서로 다른 소프트웨어/하드웨어를 이어주는 '경계면'이라고 할 수 있다.
- 이 경계면이 잘 설계되었을 때, 서로 다른 소프트웨어나 하드웨어를 쉽게 갈아끼워서 사용할 수 있게 된다.
- 만약 A 모듈이 B라는 경계면에 맞도록 구현되어있으면, 실제 모양은 다르지만 모두 B라는 경계면을 가지는 B1, B2, B3를 모두 문제없이 사용할 수 있다. 즉 호환성을 가지게 된다.
- 우리가 시스템 소프트웨어를 프로그래밍하면, 당연하게도 어떤 운영체제나 기기에서도 잘 돌아가기를 바란다. 즉 소프트웨어가 최대한 다양한 OS, 기기에 호환돼야 한다.
- API, ABI는 이 시스템 호환성에 매우 큰 영향을 끼친다. 둘 다 '인터페이스'이기 때문이다.
- 다만 이 둘의 차이가 있다면, '어떤 수준에서의 경계면이냐' '어떤 수준에서의 호환성이냐'다.

## API

- API는 소스 '코드' 수준에서의 경계면이다.
- 예를 들어, `printf()` 라는 함수를 사용했을 때 콘솔에 출력을 할 수 있다'는 인터페이스가 대표적이다.
- C 라이브러리는 메모리 관리, 문자열 처리 같은 기능을 사용할 수 있는 C 언어 인터페이스 (API)를 제공한다.
- 특정한 코드 형태 (함수, 인자)의 인터페이스를 '경계면'으로 사용해서 하나의 소프트웨어가 다른 소프트웨어를 사용할 수 있게 해준다.
- C 컴파일러는 특정한 API를 제대로 사용한 소스코드가 있다면, 컴파일과 링크를 거쳐서 우리가 원하는 바이너리 코드로 바꿔준다.

## ABI

- ABI는 바이너리 코드 수준에서의 경계면이다.
- 'aa'라는 레지스터에 1이라는 값을 넣으려면 '010010110'라는 바이너리 코드를 사용한다 같은 인터페이스가 대표적이다.
- CPU는 여러가지 연산 기능을 사용할 수 있는 바이너리 코드 인터페이스 (ABI)를 제공한다.
- 컴파일러가 소스코드를 컴파일한 결과물이, 이 시스템에서 원하는 대로 실행될 수있게 해준다.
- 만약 x86의 ABI에 맞춰서 컴파일한 코드를, ARM CPU를 가진 기기에서 돌리려고 하면 실행이 되지 않는다. 둘의 ABI가 다르기 때문이다.
- 즉, ABI는 하드웨어(CPU) 아키텍처와 밀접한 관련이 있다. 각 CPU 아키텍처마다 서로 다른 ABI를 가지고 있고, 이게 호환성에 영향을 미친다.
- 우리가 맥에서 소프트웨어 실행 파일을 다운로드 받을 때 인텔 맥용 프로그램이 따로 있고, M1 맥용 프로그램이 따로 있는 이유다. 이 둘은 ABI가 다른 CPU를 사용한다.

# '파일'이란 무엇인가?

## 유닉스 OS에서 파일은 가장 핵심적인 추상화 개념이다.

- '모든 것이 파일이다' 라는 유명한 말이 있다.
- 시스템의 모든 자원과 서비스를 파일 형태로 표현하고, 파일을 읽고 쓰는 방식으로 사용한다.
- 이렇게 하는 이유는, 이식성/호환성을 위해서다.
- 다양한 시스템 자원을 다 파일로 취급하면, 파일을 다루는 툴과 인터페이스로 다양한 시스템 자원을 사용할 수 있다.
- 이 점이 유닉스가 강조한 철학 중 하나다.
- 리눅스에서 ls, rm 같은 명령어도 사실은 하나의 파일이다.

## 파일에 접근하는 방법: 파일 디스크립터

- 시스템 콜을 사용해 파일을 열면, '파일 디스크립터'를 반환한다.
- 이 파일 디스크립터는 열려있는 파일들마다 하나씩 부여되는 고유한 정수값이다. 파일을 열 때마다 순차적으로 부여가 된다.
- 파일 디스크립터를 가지고 조작하고 닫을 수 있다. 리눅스 시스템 프로그래밍은 사실 대부분이 이 파일 디스크립터를 조작하고 닫는 작업이다.

## 리눅스에서 파일의 3가지 종류는?

### 1. 일반 파일

- 컴퓨터를 사용해본 사람이라면 누구나 파일을 들어봤을 것이다. 그렇다면 파일이란 무엇인가?
- 파일은 연속된 바이트 값의 배열이다. 다른 말로 '바이트 스트림'이라고 한다.
- 사실 아주 단순한 자료구조다. 리눅스는 이런 바이트 스트림 구조외에 별다른 자료구조를 강제하지 않는다. 스트림 안에는 어떤 값을 어떤 구조로 넣어도 상관없다.
- 파일을 조작한다는 것은 곧 파일 안에 있는 바이트 데이터를 읽고 쓴다는 뜻이다.
- 파일 내부에 데이터를 저장하는 위치를 '파일 오프셋'이라고 한다. 내가 이해하기에는 워드프로세서의 '커서'랑 비슷한 개념 같다. 열려있는 파일마다 0에서부터 시작하는 위치가 생기고, 무언가 조작을 하게 되면 그 위치에서 조작이 일어난다.
- 하나의 파일은 여러 프로세스에서 시스템 콜을 사용해 열 수 있다. 동일한 프로세스에서 여는 겄도 가능하다. 리눅스는 열 때마다 고유한 파일 디스크립터(참조)를 반환한다.

### 2. 디렉터리

- 디렉터리를 이해하기 위해 먼저 '링크'를 설명하자.
    - 처음 파일을 열려면 먼저 파일을 찾아야 한다. 보통 '파일 이름'을 가지고 파일을 찾지만, 실제 파일 시스템은 'i-node'라고 하는 정수값을 파일에 부여하고, 그걸로 파일을 찾아낸다.
    - 하지만 i-node 번호는 사람이 쓰기에는 귀찮고 보안 위협도 있다. 그래서 사람은 '파일 이름'으로 파일을 찾는다.
    - 그렇다면 특정 '파일 이름'이 어떤 'i-node 번호'를 가리키는지 알아야겠지? 마치 우리가 전화를 걸때와 같다. 전화번호를 외우기 힘들면, 이름과 전화번호를 같이 저장해놓는다. 이름-번호 쌍을 저장하는 전화번호부 같은 기능이 파일 시스템에도 필요하다.
    - 바로 '링크'다. 링크는 파일 이름과 i-node를 저장하고 있어 이름만 입력하면 실제 파일을 찾을 수 있게 해준다.
- 디렉터리는 '링크'를 모아놓은 전화번호부 파일이다.
    - 사실 디렉터리도 파일이다. i-node 번호가 있다. 다만 조금 특수한 파일이다. 디렉터리는 자신에게 속한 파일들의 링크를 저장한다.
    - 실제 파일을 찾아갈 수 있도록 정보를 저장하는 '포인터' 역할만 한다.
    - 그러나 디렉터리는 파일처럼 조작하지는 못한다. 디렉터리에는 링크 추가나, 삭제 같은 특정한 API만 있다. 디렉터리를 건드렸다가 파일 시스템 전체를 망가뜨릴 수 있기 때문이다.
    - 디렉터리는 다른 디렉터리의 링크를 가질 수 있다. 따라서 디렉터리 안에 디렉터리, 또 그 안에 디렉터리가 가능하다. 파일 이름과 i-node 번호를 가진 디렉터리이 겹쳐있고, 이 겹친 구조가 트리를 이루게 된다.
    - 이 트리 구조가 바로 우리가 잘 알고 있는 '파일 경로'를 만들게 된다.
    - 루트 디렉토리부터, /home/black/bird.png 같은 파일 경로가 있다고 하자. 그러면 이 파일 경로를 주면서 커널에게 파일을 열어달라고 요청한다. 커널은 파일 경로에서 먼저 루트 디렉터리를 찾고, 거기서 home이라는 디렉터리를, 또 그 안에서 black이라는 디렉터리를 찾는다. 최종적으로 bird.png라는 파일의 i-node를 알아낸다.
- 절대 경로와 상대 경로란?
    - 루트 디렉터리에서 시작하는 경로 이름은 완전한 형태이기 때문에 절대 경로라고 한다.
    - 완전한 형태가 아니라 디렉터리의 상대적인 위치로 나타내면 상대 경로라고 한다. 상대 경로는 현재 디렉터리를 기준으로 탐색해서 파일을 찾는다. 상대 경로 + 현재 경로를 합치면 절대 경로가 된다.

### 3. 특수 파일

- 그 외에 파일이지만 일반 파일과 다른 역할을 하는 특수 파일들이 있다. 리눅스에는 총 4개의 특수 파일이 있다.
- 1. 블록 디바이스 파일
    - 리눅스에서는 HDD, 마우스, 키보드 같은 하드웨어 디바이스도 파일이다. 디바이스 파일은 일반 파일처럼 생겼다. 디바이스 파일을 열고, 읽고 써서 하드웨어 디바이스를 조작한다.
    - 디바이스 파일과 일반 파일의 차이는, 파일을 읽고 쓰는 요청을 해당 장치의 '드라이버'가 처리한다는 것이다.
    - 이런 디바이스에는 블록 디바이스와 캐릭터 디바이스가 있다.
    - 블록 디바이스는 배열 형태여서 랜덤 액세싱이 가능하다. 고정된 크기(블록) 단위로 읽고 쓴다. 그래서 블록 파일이라고 한다.
    - 블록 디바이스는 보통 하드 디스크, CD-ROM 같은 저장장치다.
- 2. 캐릭터 디바이스 파일
    - 캐릭터 디바이스는 큐 형태이고, 실시간으로 데이터가 쌓인 순서대로 데이터가 쓰고 읽혀진다.
    - 일정한 크기에 블록 단위로 읽고 쓰는 게 아니라, 1바이트 단위로 작게 주고받는다.
    - 키보드나 마우스 입출력이 대표적이다. p, e, g를 입력하면 순서대로 p, e, g가 바로 애플리케이션에 전달된다.
- 3. 네임드 파이프
    - FIFO라고 부르기도 한다.
    - 프로세스 간 통신 방법이다. 한쪽 프로세스에서 파일에 데이터를 쓰면, 다른쪽 프로세스에서 그 데이터를 읽을 수 있다.
    - 네임드 파이프 파일에 접근해서 파일 디스크립터를 통해 조작하면 서로 다른 프로세스끼리 데이터를 주고받을 수 있다.
- 4. 소켓
    - 소켓도 다른 프로세스끼리 통신할 수 있는 IPC의 한 종류다.
    - 같은 머신이 아닌 다른 머신과도 통신이 가능하다.
    - 소켓은 네트워크와 인터넷의 근본 메커니즘이다.
    - 이 소켓 또한 리눅스에서는 파일처럼 읽고 써서 사용하게 된다.

# 파일 시스템이란 무엇인가?

## 디스크의 물리적인 조각, 섹터

- 디스크 공간을 물리적으로 나눠놓은 단위를 섹터라고 한다. 디스크의 조각이라고 보면 된다. 섹터는 거의 대부분 512 byte (0.5KB) 크기다. 디스크 공간은 수많은 섹터로 이뤄져있다. 여기에 파일을 나눠서 저장한다.
- 섹터는 한번에 하나씩 읽을 수 있는데, 이렇게 되면 GB를 넘어가는 파일들은 천만개가 넘는 섹터에 나눠진다. 그러면 이 섹터를 하나씩 읽어서 파일을 입출력하려면 너무 느리다.

## 디스크의 논리적인 조각, 블록

- 그래서 파일 시스템이 필요하다. 파일 시스템은 섹터 여러 개를 한꺼번에 읽고 쓸 수 있도록 '블록'이라는 단위로 묶어서 매핑한다.
- 각 섹터는 BIOS가 관리하는 논리 주소를 가지고 있다. 이 논리 주소를 0~3까지는 블록 1로, 4-7까지는 블록 2로 설정하는 식이다. 그래서 블록은 섹터 크기에 정수를 곱한 크기가 된다.
- 블록은 물리적으로는 존재하지 않지만, 파일 시스템이 블록에 대한 정보를 가지고 있기 때문에 사용할 수 있다.
- (파일 제어 블록, 프로세서 제어 블록 등 디스크에 저장되는 정보들이 블록이라는 단어가 들어가는 이유다. 블록 단위로 저장되기 때문.)
- 비유해보자면 디스크를 거대한 도서관이라고 한다면, 책꽂이 선반 하나가 섹터다. 도서관의 도서 관리 시스템은 각각의 선반에 도서 분류 체계를 만들고 배정을 해놓을 것이다. 그래서 어떤 책이 '사회과학/경제학'에 속한다면 그에 맞는 서가로 찾아갈 수 있도록 정보를 관리할 것이다.

## 파일 데이터와 메타 데이터

- 파일 시스템은 파일의 데이터와 파일을 관리하기 위한 메타 데이터로 나눠서 저장한다. 메타 데이터에는 파일이 담긴 블록 위치, 시간 정보, 크기 등 메타 정보가 들어가 있다.
- 파일 마다 자신이 어떤 블록을 가지고 있는지 매핑한 테이블이 기록돼있다.

## 디스크 공간 정리

- 디스크를 창고라고 한다면, 파일 시스템은 창고 관리자 같은 느낌.
- 이 뿐만 아니라, 파일의 내용을 추가하게 되면 새로운 섹터에 파일을 담아야 한다. 그런데 이 새로운 섹터 공간이 항상 인접해있을 수가 없다. 하나의 논리적인 파일이지만 물리적으로는 이곳저곳에 흩어지게 된다. 반대로 파일의 내용을 삭제하게 되어도 중간에 빈 공간이 생기게 된다.
- 이걸 효율적으로 사용하려면 관련된 파일의 섹터를 모으고 정리해줘야 한다. 하지만 디스크가 이걸 스스로할 수는 없다. 디스크는 데이터만 저장할 뿐이니까. 파일 시스템은 이렇게 디스크 공간 조각을 모아서 효율적으로 사용할 수 있게 한다.
- 도서관의 비유를 사용하자면, 도서관에 책들이 새로 생기고, 없어질 수가 있는데, 이러면 중간에 빈 공간이 생길 수 있고, 비슷한 책들이 이곳저곳 분산될 수가 있다. 이걸 주기적으로 정리해주는 게 사서의 역할이고, 파일 시스템또한 비슷한 역할을 해주는 것 같다.

## 파일 시스템을 왜 사용하는가?

- 정리하자면, 파일 시스템은 커널에서 디스크를 빠르고 효율적으로 사용하기 위해 필요한 소프트웨어다.
    - 블록을 계산해서 데이터를 더 빠르게 읽고 쓸 수 있도록 한다.
    - 물리적으로 분산되어있지만, 논리적으로 연관된 데이터를 찾을 수 있게 해준다.
    - 연관된 섹터를 모으고 정리해서 디스크 공간을 효율적으로 사용하게 해준다.

## 대표적인 파일 시스템

- 디스크 저장공간을 사용하는 시스템이라면 파일 시스템이 반드시 필요하다. 그래서 운영체제에는 필수로 파일 시스템이 포함돼있다.
    - 윈도우는 FAT(12/16/32, exFAT), NTFS
    - 리눅스는 ext(2/3/4)
    - 맥OS는 HFS+, APFS

## 리눅스의 파일 시스템

- 리눅스는 초기에 미닉스에서 사용하던 '미닉스 파일 시스템'을 사용했다.
- 하지만 미닉스 파일 시스템은 최대 파일 크기가 64MB밖에 안 됐고, 파일 이름도 14글자가 최대였다. 파일 시스템마다 최대 할당할 수 있는 블록 개수가 다르기 때문이다.
- 그래서 새롭게 개발한 확장 파일 시스템 (Extended File System)이 리눅스 기본 파일 시스템이 된다.
- 파일 용량은 2GB, 파일 이름은 255글자까지 가능하다.
- 그 외에도 가상 파일 시스템을 도입해서 호환성을 높였다.

## 네임스페이스

- 저장 장치 별로 파일 시스템은 다를 수 있다. 도서관마다 도서 관리 시스템이 다를 수 있듯이. 또는 하나의 저장 공간 안에도 파티션을 나눠서 다른 파일 시스템을 사용할 수도 있다.
- 윈도우는 파일 저장 경로를 정할 때 플로피 디스크는 A 드라이브, 하드 디스크는 C 드라이브 등으로 네임스페이스 (주소 공간)를 따로 구분한다.
- 하지만 유닉스/리눅스에서는 여러개의 장치도 하나의 네임스페이스에 통합시켜서 사용한다.
- 리눅스의 기본 파일 시스템 (루트 파일 시스템) 안의 특정 위치에 외부 장치의 파일 시스템을 '마운트' 시킬 수 있다. 그러면 마운트 시킨 위치가 외부 장치의 '루트'가 된다. 외부 저장 장치도 같은 계층 구조 안에서 사용한다.

## 링크

- 디렉터리는 '링크'를 저장한 파일이라고 했다. 링크는 파일을 복사하지 않고도 공간을 절약하면서 여러 경로에서 같은 파일에 접근할 수 있기 때문에 쓴다.
- 링크에는 하드 링크, 심벌릭 링크가 있다.

### 하드 링크

- 하드 링크는 똑같은 i-node를 가리키되 서로 다른 파일 이름을 가진다. 같은 i-node에 이름만 여러개라고 생각하면 된다. 이 링크는 각각 다른 디렉터리에 존재할 수 있어서 파일의 접근성을 높인다.
- 디렉터리에서 원본 링크로 파일을 삭제한다. 이때 원본 링크는 삭제되지만, 다른 하드링크는 여전히 남아있을 수 있다. 파일 시스템은 링크의 개수를 센다. 특정 i-node에 더 이상 링크가 존재하지 않으면, 실제 파일은 그때 삭제된다.

### 심벌릭 링크

- 심벌릭 링크는 i-node가 아니라 파일 이름이 특정한 파일 경로(이름)을 가리킨다. 파일 이름에 참조가 걸려있기 때문에 파일 경로(이름)이 같다면 i-node가 달라도 링크가 작동한다.
- 심벌릭 링크는 별도의 i-node를 가진다. 파일인데 '다른 파일의 경로만' 담고 있는 파일이라고 할 수 있다.
- i-node는 하나의 파일 시스템에서만 고유하다. 따라서 한 파일 시스템에서 다른 파일 시스템을 가리킬 때는 심벌릭 링크를 사용한다.
- 원본 링크, 하드 링크로 내용을 수정하면 심볼릭 링크가 가리키는 파일 내용도 똑같이 수정된다.
- 반면 파일을 복사하면, 원본과 내용은 같지만, i-node도 다르고, 기존 파일에 영향을 받지 않는 파일이 만들어진다.

---