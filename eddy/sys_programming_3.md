## 저수준 입출력과 고수준 입출력

| 저수준 입출력  | 고수준 입출력 |
| --- | --- |
| 커널을 직접 호출해 파일 입출력을 수행한다.  | C 표준 입출력 라이브러리 함수를 사용한다. |
| 속도가 빠르다.  | 속도가 상대적으로 느리다. (고수준 입출력 함수는 저수준 파일 입출력을 사용해서 만든다.) |
| 바이트 단위로 파일을 다룬다.  | 버퍼 단위로 파일을 다룬다. |
| 파일을 다룰 때 ‘파일 디스크립터'를 사용한다. int fd | 파일을 다룰 때 ‘파일 포인터'를 사용한다. FILE 이라는 구조체에 파일 정보가 기록된다. FILE *fp |
|  | 편의상의 여러가지 형식을 지원한다. |

## 고수준 입출력이 버퍼를 사용하는 이유

<aside>
💡 파일 시스템의 ‘블록’과 애플리케이션의 문자, 행 단위를 연결하기 위해서

</aside>

- 파일 시스템은 ‘블록’ 단위를 쓴다.
    - 블록은 파일 시스템 최소 저장 단위를 나타내는 개념이다.
    - 블록 크기의 정수배 단위로 연산을 수행하면 성능 개선을 얻을 수 있다.
    - 커널가 하드웨어이 블록 크기를 기준으로 대화하기 때문이다. 따라서 블록 크기에 딱 들어맞는 값을 쓰면 정렬된 입출력 요청을 보장하므로 추가 작업이 줄어든다.
    - 보통은 블록 크기의 정수배 크기 버퍼를 사용해서 입출력을 수행한다. 4KB나 8KB를 주로 사용한다. 하지만 모든 데이터를 이 단위로 취급할 수 있을까? 프로그램은 블록 같은 추상 개념이 아니라 필드, 행, 단일 문자를 다루다.
    - 여기서 사용자 버퍼 입출력이 등장한다.
- 사용자 버퍼 입출력. 버퍼를 사용해 블록 단위로 읽고 쓴다.
    - 블록 단위로 동작하는 단위 시스템과 행, 문자 단위를 사용하는 애플리케이션 사이를 연결한다.
    - 일단 데이터가 쓰여지면, 버퍼에 먼저 저장된다. 그러다가 버퍼가 특정 크기에 도달하면, 버퍼를 통째로 쓰기 연산을 한다. 읽기도 버퍼 크기에 맞춰서 읽게 된다.
- 애플리케이션에서 어떤 단위로 입출력 요청을 하더라도, 파일 시스템에는 항상 블록 크기에 맞춰서 시스템 콜이 들어가게 되는 것이다.

# 표준 입출력

- 표준 C 라이브러리에 구현된 사용자 버퍼 입출력을 설명한다.

## 파일 포인터

- 표준 입출력이 저수준 입출력과 다른 점. 파일 디스크립터를 직접 다루지 않는다.
- 파일 포인터라는 식별자를 사용한다.
- 열려있는 파일 포인터를 스트림이라고도 한다.

# 1. 파일 열기 & 닫기

## 파일 열기: fopen()

- 고수준 파일 입출력에서 파일을 여는 함수는 fopen입니다. fopen 함수는 파일 포인터를 리턴합니다.

```c
#include <stdio.h>

FILE *fopen(const char *filename, const char *mode);
// filename : 파일의 경로, mode : 파일 열기 모드
```

### 모드

| r | 읽기용 |
| --- | --- |
| r+ | 읽기/쓰기용. |
| w | 쓰기용. 
파일이 이미 존재하면 길이를 0으로 자른다. 파일이 없으면 새로 만든다. |
| w+ | 읽기/쓰기용. |
| a | 덧붙이기 상태. 
파일이 없으면 새로 만든다.  |
- fopen()은 성공하면 파일 포인터를 반환.
- 실패하면 NULL을 반환하고, `errno`에 값을 설정한다.

## 파일 닫기: fclose()

```c
#include <stdio.h>

int fclose(FILE *stream);
// stream : fopen에서 리턴한 파일 포인터.

int fcloseall(void);
// 현제 프로세스와 관련된 모든 스트림을 닫는다.
```

# 2. 단일 문자 단위 입출력

- 문자 단위로 읽기: `fgetc()`
    - 이 함수는 다음 문자를 읽고 unsigned char 타입을 int로 변환해서 return한다.
    - char 타입이 아닌 int 타입이므로 조심하자.
- 문자 단위로 쓰기 : `fputc()`
    - `c` 라는 바이트를 스트림에 쓴다.

## 3. 문자열 단위 입출력

- 여러 글자 단위로 읽기: `fgets()`
    - size 보다 하나 적은 내용을 읽고 결과를 str에 저장한다.
    - 마지막 바이트에는 null 문자를 저장한다.
    - 개행 문자가 있다면 \n 문자를 저장한다.
- 여러 글자 단위로 쓰기: `fputs()`
    - str이 가리키는 문자열을 stream에 기록한다.
    - 성공하면 음수 아닌 값을 반환하고, 실패하면 EOF.

```c
#include <stdlib.h>
#include <stdio.h>

int main() {
	FILE *read_fp, *write_fp;
	char buf[BUFSIZE];

	if ((read_fp = fopen("linux.txt"), "r") == NULL) {
		perror("fopen: linux.txt")'
		exit(1)
	}

	if ((write_fp = fopen("linux.out"), "a") == NULL) {
		perror("fopen: linux.out")
		exit(1);
	}

	while (fgets(buf, BUFSIZE, read_fp) != NULL) {
		fputs(buf, write_fp);
	}

	fclose(read_fp);
	fclose(write_fp);
}
```

## 4. 바이너리 데이터로 입출력

- 바이너리 데이터 읽기: `fread()`
    - `size` 바이트 크기의 요소를 `nr`개 읽어서 `buf`가 가리키는 버퍼에 저장한다.
    - 바이너리 데이터는 아키텍처 ABI가 동일한 경우에만 일관적으로 읽고 쓸 수 있다.
    
    ```c
    char buf[64];
    size_t nr;
    
    nr = fread(buf, sizeof(buf), 1, stream);
    if (nr == 0) 
    /* error */
    ```
    
- 바이너리 데이터 쓰기: `fwrite()`
    - buf 가 가리키는 데이터에서 size 크기의 엘리먼트 nr개를 stream에 쓴다.
    

## 5. 파일 디스크립터 ← → 파일 포인터 변환

- 파일 디스크립터 → 파일 포인터
    - `FILE *fdopen(ind fd, const char *mode);`
- 파일 포인터 → 파일 디스크립터
    - `int fileno(FILE *stream);`
- 표준 입출력 함수와 시스템 콜 사이에 버퍼링 관련 충돌이 있을 수 있다.
    - 그러므로 파일 디스크립터를 사용하기 전에 스트림(파일 포인터)를 비우면 좋다.
    - 파일 디스크립터와 스트림을 섞어서 쓰지 않도록 하자.
- 스트림 비우기 `fflush()`
    - stream에 있는 쓰지 않은 데이터를 커널로 비운다. qjarms123!@#
    
    ```c
    #include <stdio.h>
    
    int fflush(FILE *stream);
    ```