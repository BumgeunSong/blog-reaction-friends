# 네트워크 보안

## 안전한 커뮤니케이션이란?

1. 기밀성 (컨피덴셜리티)
    - 보내는 사람과 수신자만 메시지의 내용을 이해할 수 있어야 한다.
    - 가장 흔한 보안의 개념이다.
2. 메시지 무결성 (Integrity)
    - 고의적이든 아니든, 메시지의 내용이 전송 중에 바뀌지 않아야 한다.
    - 체크섬 기술과 데이터 전송 프로토콜을 이용해서 메시지의 진본성을 확보한다.
3. 엔드포인트 인증
    - 발신자와 수신자는 커뮤니케이션에 참여하는 반대편의 아이덴티티를 확인할 수 있어야 한다.
    - 대면 커뮤니케이션은 시각적 인식을 통해 이 문제를 해결할 수 있다.
    - 하지만 비대면 커뮤니케이션에서는 상대방이 진짜 상대방인지 확인하는 일이 그렇게 간단하지 않다.
4. 운영적 보안
    - 공격자는 바이러스를 호스트에 넣을 수도 있고, 기업 기밀이나 네트워크 설정을 바꾸려 할 수도 있다.
    - 방화벽이나 침입 탐지 시스템이 이런 운영적 보안 공격을 막기 위해서 사용되는 걸 알아보도록 하자.
    

## 대칭키 암호화

- 암호화 알고리즘은 평문을 계산이나 변경을 거쳐서 암호문으로 바꾼다.

## 시저 사이퍼

- 아주 단순한 알고리즘은 ‘시저 사이퍼'라고 알려진 대칭키 알고리즘이다.
- 시저 사이퍼는 알파멧을 k개 뒤의 알파벳으로 바꾼다. k가 3이면 a는 d로 바꾸는 식이다.
- 만약 이게 시저 사이퍼라는 걸 안다면 암호를 깨는 것은 어렵지 않다. 25개의 키-밸류 조합만 있기 때문이다.

## Mono alphabetic cipher

- 이것을 좀 더 개선시켜보자.
- 하나의 알파벳을 다른 알파벳으로 바꾼다. 하지만 일정한 패턴으로 바꾸는 대신, 특정 글자를 랜덤한 다른 글자로 바꾼다.
- 평문을 바꾸는 특정한 인코딩 로직을 만드는 것이다.
- 10개의 글자가 있다면, 모두 26가지의 가능성을 가지기 때문에 가능한 평문의 조합은 10 26승이 된다.
- 하지만 이것도 e나 t가 자주 쓰이는 글자라는 통계적인 사실을 대입하고, 특히 2-3개가 연속해서 쓰이는 조합이 많다(in, it, the) 등을 대입하면 암호를 깨는 것이 좀 더 쉬워진다.
- 게다가 메시지의 내용에 대해서 어느 정도 신뢰할만한 가정이 있다면, 가능성은 더 높아진다.

## Poly alphabetic Encryption

- 여러개의 모노알파베틱 사이퍼를 사용한다.
- 2개의 시저 사이퍼를 이용해서, 만약 C1, C2이 있다면,
- C1, C2, C1 순으로 섞어가면서 사용한다.
- 섞어가는 패턴 자체가 암호가 된다.

## 블록 사이퍼

이제 현대로 돌아와보자. 대칭 암호화 기술에는 크게 2종류가 있다.

- stream chiper와 block cipher다.
- stream 사이퍼는 무선 랜에 사용된다.
- 대부분의 인터넷 프로토콜에서는 블록 사이퍼를 쓴다.

블록 사이퍼에서는 메시지가 k bit의 블록으로 나눠진다. k가 64이면 64비트 블록으로 나눈다. 각각은 독립적으로 암호화된다. 

블록 사이즈가 3이라고 해보자. 3비트짜리 평문을 3비트짜리 암호분으로 바꾼다. 3비트에서는 총 8개의 수를 매핑한다.

매핑 테이블의 경우의 수는 몇개가 있을까? 8개의 수를 가지고 매핑 테이블을 만들 수 있으므로 8! = 40,320개의 방법이 있다.

이 정도면 쉽게 풀릴 수 있다.

하지만 비트가 64개 혹은 그 이상이라면, $2^K!$ 개의 조합이 가능하다. 천문학적인 숫자다.

블록 사이퍼는 이 테이블 대신에 이런 테이블을 흉내내는 함수를 사용한다. 비트를 나눠서 섞는다.

인기있는 블록 사이퍼가 여러개 있다. DES, AES 등이다. 각각은 정해진 테이블이 아닌 함수를 사용한다. 

DES는 64비트 블록과 56비트 키를 사용한다. AES는 128비트 블록을 사용한다.

### Cipher Block Chaining

블록 사이퍼는 사이퍼 블록 체이닝이라는 기술을 사용한다. 하나의 랜덤한 값을 첫번째 메시지에 같이 보낸다. 그리고 발신자와 수신자가 랜덤 넘버 대신에 계산된 코드 블록을 사용한다.

발신자가 초기화 벡터라는 k 비트 string을 생성한다. 

### 대칭키 암호화

대칭키 암호화는 여는 키와 잠그는 키가 같다. 

간단하고 연산이 효율적이다. 하지만 상대방과 대칭키를 공유해야 하는데, 이걸 안전하게 전달하기가 어렵다. 키가 유출되면 암호화는 말짱 꽝이다. 대칭키 자체를 암호화하면, 또 그 대칭키를 암호화한 키를 공유해야 하는 문제가 발생한다. 

## 공개키 암호화 Public Key Encryption

- 시저 사이퍼의 시대부터 50년전까지 거의 2천년간, 암호 통신이라는 것은, 서로 간에 공통의 비밀이 있다는 것을 전재로 했다.
- 암호화, 복호화를 위한 대칭키다
- 하지만 이 키를 안전하게 공유하는 것은 쉽지가 않다.
- 컴퓨터 네트워킹의 세계에서는 서로 전혀 만난 사람이 없고, 서로 마주칠 일도 없는 상대와 통신을 해야한다. 어떻게 비밀 키를 공유할 수 있을까?
- 1976년도에 디피와 헬만이 디피-헬만 키 교환 알고리즘이라는 걸 만들었다. 이 알고리즘은 오늘날의 공개키 암호화 시스템의 근간이 된다.

## 키가 2개인 **공개키 암호화**

앨리스와 밥이 암호로 소통하고 싶다. 수신자인 밥은 2개의 키를 가지고 있다. 누구나 알고 있는 공개키와 자신만 알고 있는 비밀키가 있다. 

밥한테 메시지를 보내려면, 먼저 밥의 공개키와 표준 암호화 알고리즘을 알아내야 한다. 그 뒤에 앨리스는 밥의 공개키와 알고리즘을 가지고, 암호문을 만든다. 

밥은 앨리스의 암호문을 받아서, 자신의 비밀키를 이용해 복호화한다. 

## 공개키 암호화의 2가지 문제

첫번째 문제는 공격자가 암호문을 만들 수 있게 된다는 것이다. 

밥의 공개키와 암호화 알고리즘을 알게 된다. 그러면 만약에 공격자가 앨리스가 보낼거라고 예상되는 메시지를 가정할 수 있다면, 앨리스가 보낼 거라고 예상되는 메시지의 일부를 인코딩할 수 있다. **선택평문공격이라고 한다.** (CPA; Chosen Plaintext Attack)

예를 들어 앨리스가 ‘오늘 저녁'이라는 말을 쓸 것 같다면, 오늘 저녁이라는 것을 암호화해서 어떤 텍스트가 나오는지 보고, 그걸 바탕으로 암호문을 해석할 수 있게되는 것이다.

두번째 문제는 공격자가 ‘앨리스인 척’ 할 수 있다는 것이다.

대칭키 알고리즘에서는, 상대방이 비밀키를 알고 있다는 것 자체가 신원을 보증한다. 하지만 공개키 알고리즘에서는 누구나 ‘암호화'를 할 수 있다. 

따라서 이 문제를 해결하기 위해서는 ‘디지털 서명'이라는 게 필요해진다. 뒤에 더 알아보자.

## RSA

이 2가지 문제를 해결하는 알고리즘이 여러개 있지만, RSA 알고리즘이 가장 유명하고, 거의 공개키 알고리즘의 동의어로 쓰일 정도다.

RSA 알고리즘은 암호화, 복호화에 시간이 많이 걸린다. 대칭키 알고리즘인 DES는 RSA보다 천배에서 만배 정도 빠르다. 따라서 RSA는 실제로는 단독으로 쓰이기보다, 대칭키 알고리즘과 조합해서 쓰게 된다. 대칭키 알고리즘의 키를 공유하는 용도로 사용하는 것이다. 이러면 많은 양의 데이터를 주고받을 때도 부하가 많이 걸리지 않는다.

RSA의 원리는 상당히 수학적으로 복잡한 내용이다. 아래 영상을 보고 천천히 정리할 예정.

[https://youtu.be/EPXilYOa71c](https://youtu.be/EPXilYOa71c)

## 디지털 서명

- 안전한 커뮤니케이션의 특성 중 하나는 메시지의 무결성이다.
- 디지털 서명과 엔드 포인트 인증이 중요해지는 이유다.

## 1. 해시 함수

암호학 해시 함수는 디지털 서명에 굉장히 중요하게 사용된다.

해시란 으깬다는 뜻이다. 해시드 포테이토 = 으깬 감자

해시 함수에 어떤 임의의 길이의 데이터를 넣으면, 해시 함수는 잘개 으깨서(?) 고정된 크기의 값으로 바꿔준다. 이 값은 원래 데이터를 알 수 없는 가비지 데이터처럼 보인다. 해시 함수의 아웃풋을 가지고, 인풋을 알아내는 것은 불가능할 정도로 어렵다.

즉, 해시를 사용하면 실제 값을 알려주지 않으면서, 데이터를 저장할 수 있게 된다. 만약에 비밀번호를 그냥 저장하면 해킹을 당했을 때 그걸 사용할 수 있게 되지만, 비밀번호를 ‘해싱’해서 저장하게 되면, 해킹을 해도 해커는 원래 비밀번호를 알 수 없다.

하지만 사용자가 비밀번호를 제시하면, 해시를 사용해서 값을 계산해본다음 그게 저장된 해시랑 맞는지 확인해보면 비밀번호가 진짜인지 아닌지 알 수 있다.